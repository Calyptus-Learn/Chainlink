// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";


contract DynamicNFT is ERC721, ERC721URIStorage, Ownable {
 using Counters for Counters.Counter;
 Counters.Counter private _tokenIdCounter;
 string[] IpfsUri = [
     "ipfs://QmbgYwcxMGT2Qt5XKEWfDqJdtG8g8CgdPrppZBvKWF2kFm/Stage1.json",
     "ipfs://QmbgYwcxMGT2Qt5XKEWfDqJdtG8g8CgdPrppZBvKWF2kFm/Stage2.json",
     "ipfs://QmbgYwcxMGT2Qt5XKEWfDqJdtG8g8CgdPrppZBvKWF2kFm/Stage3.json",
     "ipfs://QmbgYwcxMGT2Qt5XKEWfDqJdtG8g8CgdPrppZBvKWF2kFm/Stage4.json"
 ];
  uint256 lastTimeStamp;
 uint256 interval;
  constructor(uint _interval) ERC721("Dynamic NFTs", "dNFT") {
     interval = _interval;
     lastTimeStamp = block.timestamp;
 }
 function checkUpkeep(bytes calldata /* checkData */) external view  returns (bool upkeepNeeded, bytes memory /* performData */) {
     upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
     // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
 }
 function performUpkeep(bytes calldata /* performData */) external  {
     //We highly recommend revalidating the upkeep in the performUpkeep function
     if ((block.timestamp - lastTimeStamp) > interval ) {
         lastTimeStamp = block.timestamp;
         levelUp(0);
     }
     // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
 }
 function levelUp(uint256 _tokenId) public {
     if(currentStage(_tokenId) >= 3){return;}
     // Get the current stage of the flower and add 1
     uint256 newVal = currentStage(_tokenId) + 1;
     // store the new URI
     string memory newUri = IpfsUri[newVal];
     // Update the URI
     _setTokenURI(_tokenId, newUri);
 }
 // determine the stage of the flower growth
 function currentStage(uint256 _tokenId) public view returns (uint256) {
     string memory _uri = tokenURI(_tokenId);
     // Stage 1
     if (compareStrings(_uri, IpfsUri[0])) {
         return 0;
     }
     // Stage 2
     if (
         compareStrings(_uri, IpfsUri[1])
     ) {
         return 1;
     }
     // Stage 3
     if (
         compareStrings(_uri, IpfsUri[2])
     ) {
         return 2;
     }
     // Must be Stage 4
     return 3;
 }
 // helper function to compare strings
 function compareStrings(string memory a, string memory b)
     public
     pure
     returns (bool)
 {
     return (keccak256(abi.encodePacked((a))) ==
         keccak256(abi.encodePacked((b))));
 }
  function safeMint(address to) public {
      uint256 tokenId = _tokenIdCounter.current();
      _tokenIdCounter.increment();
      _safeMint(to, tokenId);
      _setTokenURI(tokenId, IpfsUri[0]);
  }
 // The following functions are overrides required by Solidity.
 function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
     super._burn(tokenId);
 }
 function tokenURI(uint256 tokenId)
     public
     view
     override(ERC721, ERC721URIStorage)
     returns (string memory)
 {
     return super.tokenURI(tokenId);
 }
}
